(* ::Package:: *)

(* ::Subsubsection:: *)
(*Elastic net intial parameters*)


(* ::Text:: *)
(*Steps:*)
(*1) Import data *)
(*2) Monte Carlo cross validation to determine optimal Logistic elastic net regularisation parameters*)
(*3) Export*)


(* ::Input:: *)
(*(*Set dir and import data*)*)
(*dirData="/Users/thomasmellan/Downloads/numerai_datasets"*)
(*trainingData=Import[StringJoin[dirData,"/numerai_training_data.csv"]];*)
(**)
(*(*Global parameters*)*)
(*eraTotalNumber=120; (*Numer of eras in training data. This should be automatic in case it changes*)*)
(*RegSize=4 (*L1 L2 regularisation domain size (square)*)*)
(*intialRegParameters={1,1}; (*Initial L1=L2=1*)*)
(**)
(*(*Get number of points in each era*)*)
(*eraLabels=Table[StringJoin["era",ToString@i],{i,1,eraTotalNumber}];*)
(*erasNames=Transpose[trainingData][[2]];*)
(*eraLengths=Table[Cases[erasNames,eraLabels[[i]]]//Length,{i,1,Length@eraLabels}];*)
(*eraLengthsCumulative=Join[{0},Table[Total@eraLengths[[1;;i]],{i,1,Length@eraLengths}]];*)
(**)
(*(*Split data era-wise*)*)
(*fullTrainingSet=(Join[{StringDelete[#[[2]],"era"]},#[[4;;-6]]]->#[[-5;;-5]][[1]])&/@trainingData[[2;;-1]];*)
(*fullTrainingSplit=Table[fullTrainingSet[[eraLengthsCumulative[[era]]+1;;eraLengthsCumulative[[era+1]]]],{era,1,Length@eraLabels}];*)
(*fullTrainingSetDataOnly=(#[[1]]&/@fullTrainingSet);*)
(**)
(*(*Elastic net parameters determined by Monte Carlo cross validation, and a Gaussian process fitted to the log loss in L1-L2 parameter space*)*)
(*boLogistic=With[*)
(*{nFold=10,kSubSamplesT=500,kSubSamplesV=1000,mErasT=10,mErasV=1,gaussianResolution=25},*)
(*randomEraSample=Table[RandomSample[Range[eraTotalNumber],mErasT+mErasV],{n,1,nFold}];*)
(*{eraSplitTrain,eraSplitVal}={Table[randomEraSample[[n]][[1;;mErasT]],{n,1,nFold}],Table[randomEraSample[[n]][[mErasT+1;;mErasT+mErasV]],{n,1,nFold}]};*)
(*{eraSplitSubsampleIndexTrain,eraSplitSubsampleIndexVal}={Table[Table[RandomSample[Range[eraLengths[[eraSplitTrain[[n]][[split]]]]],kSubSamplesT],{split,1,mErasT}],{n,1,nFold}],Table[Table[RandomSample[Range[eraLengths[[eraSplitVal[[n]][[split]]]]],kSubSamplesV],{split,1,mErasV}],{n,1,nFold}]};*)
(*{trainingSplits,valSplits}={Table[Flatten@Table[fullTrainingSplit[[eraSplitTrain[[n]][[era]]]][[eraSplitSubsampleIndexTrain[[n]][[era]]]],{era,1,mErasT}],{n,1,nFold}],Table[Flatten@Table[fullTrainingSplit[[eraSplitVal[[n]][[era]]]][[eraSplitSubsampleIndexVal[[n]][[era]]]],{era,1,mErasV}],{n,1,nFold}]};*)
(*crossVal[n_,{\[Lambda]1_,\[Lambda]2_}]:=Module[{class},class=Classify[trainingSplits[[n]],PerformanceGoal->"Quality",Method->{"LogisticRegression","OptimizationMethod"->"StochasticGradientDescent","L1Regularization"->Exp[\[Lambda]1],"L2Regularization"->Exp[\[Lambda]2]}];*)
(*-ClassifierMeasurements[class,valSplits[[n]],"LogLikelihoodRate"]];*)
(*lossOptimiserFunction[{\[Lambda]1_,\[Lambda]2_}]:=Mean[Table[crossVal[n,{\[Lambda]1,\[Lambda]2}],{n,1,*)
(*nFold}]];*)
(*regSpace[init_,size_]:=Rectangle[{init[[1]]-size,init[[2]]-size},{init[[1]]+size,init[[2]]+size}];*)
(*BayesianMinimization[lossOptimiserFunction,regSpace[intialRegParameters,RegSize],MaxIterations->gaussianResolution,AssumeDeterministic->False]*)
(*]*)
(**)
(*(*Get best log-loss actually calculated, and best log-loss from Gaussian process over log-loss, and plot of logloss surface*)*)
(*pLogistic=boLogistic["PredictorFunction"]*)
(*minConfigValue=Append[boLogistic["MinimumConfiguration"], boLogistic["MinimumValue"]]*)
(*minConfigFunction=FindArgMin[pLogistic[{x,y}],{{x},{y}}]*)
(*pNet=Plot3D[pLogistic[{x,y}],{x,intialRegParameters[[1]]-RegSize,intialRegParameters[[1]]+RegSize},{y,intialRegParameters[[2]]-RegSize,intialRegParameters[[2]]+RegSize},PlotRange->All,ImageSize->1000,AxesLabel->{"Logloss","Exp[L1]","Exp[L2]"}]*)
(*pNetTable=Table[pLogistic[{x,y}],{x,intialRegParameters[[1]]-RegSize,intialRegParameters[[1]]+RegSize},{y,intialRegParameters[[2]]-RegSize,intialRegParameters[[2]]+RegSize},PlotRange->All]*)
(**)
(*(*Export image of L1-L2 logloss surface, and L1-L2 values with best logloss*)*)
(*Export[StringJoin[dir,"/pNet.pdf"],pNet]*)
(*Export[StringJoin[dir,"/minConfigValue.txt"],minConfigValue]*)
(*Export[StringJoin[dir,"/mminConfigFunction.txt"],minConfigFunction]*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)


(* ::Input:: *)
(**)
